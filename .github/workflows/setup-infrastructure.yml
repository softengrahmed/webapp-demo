name: 🏗️ Setup Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_recreate:
        description: 'Force recreate existing resources'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: 'us-east-1'
  TERRAFORM_VERSION: '1.5.0'

jobs:
  setup-infrastructure:
    name: 🏗️ Infrastructure Setup
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    timeout-minutes: 45
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
    
    - name: ⚙️ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: 🔧 Setup Terraform

      uses: hashicorp/setup-terraform@v3

      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: 🏗️ Create S3 bucket for frontend
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        BUCKET_NAME="webapp-demo-$ENVIRONMENT-frontend"
        
        echo "🪣 Creating S3 bucket: $BUCKET_NAME"
        
        # Check if bucket exists
        if aws s3api head-bucket --bucket $BUCKET_NAME 2>/dev/null; then
          if [ "${{ github.event.inputs.force_recreate }}" = "true" ]; then
            echo "🔄 Force recreate enabled, emptying bucket..."
            aws s3 rm s3://$BUCKET_NAME --recursive
          else
            echo "✅ Bucket already exists: $BUCKET_NAME"
          fi
        else
          echo "🆕 Creating new bucket..."
          aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        fi
        
        # Configure bucket for static website hosting
        echo "🌐 Configuring static website hosting..."
        aws s3 website s3://$BUCKET_NAME \
          --index-document index.html \
          --error-document index.html
        
        # Set bucket policy for public read access
        cat > bucket-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "PublicReadGetObject",
              "Effect": "Allow",
              "Principal": "*",
              "Action": "s3:GetObject",
              "Resource": "arn:aws:s3:::$BUCKET_NAME/*"
            }
          ]
        }
        EOF
        
        aws s3api put-bucket-policy \
          --bucket $BUCKET_NAME \
          --policy file://bucket-policy.json
        
        echo "FRONTEND_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
    
    - name: ⚡ Setup Lambda execution role
      run: |
        ROLE_NAME="webapp-demo-lambda-execution-role"
        
        echo "🔐 Setting up Lambda execution role: $ROLE_NAME"
        
        # Check if role exists
        if aws iam get-role --role-name $ROLE_NAME >/dev/null 2>&1; then
          echo "✅ Role already exists: $ROLE_NAME"
        else
          echo "🆕 Creating Lambda execution role..."
          
          # Create trust policy
          cat > trust-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "lambda.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }
          EOF
          
          # Create role
          aws iam create-role \
            --role-name $ROLE_NAME \
            --assume-role-policy-document file://trust-policy.json
          
          # Attach basic execution policy
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          
          # Attach VPC access policy (for RDS access)
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
        fi
        
        ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text)
        echo "LAMBDA_ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV
    
    - name: 🌐 Setup VPC and Security Groups
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        VPC_NAME="webapp-demo-$ENVIRONMENT-vpc"
        
        echo "🌐 Setting up VPC: $VPC_NAME"
        
        # Check if VPC exists
        VPC_ID=$(aws ec2 describe-vpcs \
          --filters "Name=tag:Name,Values=$VPC_NAME" \
          --query 'Vpcs[0].VpcId' \
          --output text 2>/dev/null || echo "None")
        
        if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
          echo "✅ VPC already exists: $VPC_ID"
        else
          echo "🆕 Creating VPC..."
          
          # Create VPC
          VPC_ID=$(aws ec2 create-vpc \
            --cidr-block 10.0.0.0/16 \
            --query 'Vpc.VpcId' \
            --output text)
          
          # Tag VPC
          aws ec2 create-tags \
            --resources $VPC_ID \
            --tags Key=Name,Value=$VPC_NAME
          
          # Create subnets
          SUBNET1_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.1.0/24 \
            --availability-zone ${AWS_REGION}a \
            --query 'Subnet.SubnetId' \
            --output text)
          
          SUBNET2_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.2.0/24 \
            --availability-zone ${AWS_REGION}b \
            --query 'Subnet.SubnetId' \
            --output text)
          
          # Tag subnets
          aws ec2 create-tags \
            --resources $SUBNET1_ID $SUBNET2_ID \
            --tags Key=Name,Value="$VPC_NAME-subnet"
        fi
        
        echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV
    
    - name: 📋 Generate infrastructure summary
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        
        cat > infrastructure-summary.md << EOF
        # 🏗️ Infrastructure Setup Summary
        
        **Environment**: $ENVIRONMENT
        **Region**: ${{ env.AWS_REGION }}
        **Timestamp**: $(date)
        
        ## 📱 Frontend Infrastructure
        - **S3 Bucket**: ${FRONTEND_BUCKET}
        - **Website URL**: http://${FRONTEND_BUCKET}.s3-website-${{ env.AWS_REGION }}.amazonaws.com
        - **Status**: ✅ Ready
        
        ## ⚡ Backend Infrastructure
        - **Lambda Role ARN**: ${LAMBDA_ROLE_ARN}
        - **VPC ID**: ${VPC_ID}
        - **Status**: ✅ Ready
        
        ## 🔄 Next Steps
        1. Run the database provisioning workflow
        2. Deploy your application using the main pipeline
        3. Configure monitoring and alerts
        
        ## 💡 Cost Optimization
        - S3 bucket configured for standard storage
        - Lambda cold starts minimized with provisioned concurrency (when needed)
        - VPC endpoints can be added to reduce NAT gateway costs
        
        EOF
        
        echo "✅ Infrastructure setup completed!"
    
    - name: 💾 Upload infrastructure artifacts

      uses: actions/upload-artifact@v4

      with:
        name: infrastructure-${{ github.event.inputs.environment }}-${{ github.run_id }}
        path: |
          infrastructure-summary.md
          *.json
        retention-days: 90