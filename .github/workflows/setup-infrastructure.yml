name: ðŸ—ï¸ Setup Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_recreate:
        description: 'Force recreate existing resources'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: 'us-east-1'
  TERRAFORM_VERSION: '1.5.0'

jobs:
  setup-infrastructure:
    name: ðŸ—ï¸ Infrastructure Setup
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    timeout-minutes: 45
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ðŸ”§ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: ðŸ—ï¸ Create S3 bucket for frontend
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        BUCKET_NAME="webapp-demo-$ENVIRONMENT-frontend"
        
        echo "ðŸª£ Creating S3 bucket: $BUCKET_NAME"
        
        # Check if bucket exists
        if aws s3api head-bucket --bucket $BUCKET_NAME 2>/dev/null; then
          if [ "${{ github.event.inputs.force_recreate }}" = "true" ]; then
            echo "ðŸ”„ Force recreate enabled, emptying bucket..."
            aws s3 rm s3://$BUCKET_NAME --recursive
          else
            echo "âœ… Bucket already exists: $BUCKET_NAME"
          fi
        else
          echo "ðŸ†• Creating new bucket..."
          aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        fi
        
        echo "FRONTEND_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
    
    - name: ðŸ” Configure S3 Block Public Access
      run: |
        BUCKET_NAME="$FRONTEND_BUCKET"
        
        echo "ðŸ” Configuring Block Public Access for static website hosting..."
        echo "ðŸ“‹ Current settings:"
        aws s3api get-public-access-block --bucket $BUCKET_NAME || echo "No current Block Public Access configuration"
        
        echo "ðŸ”§ Updating Block Public Access settings..."
        # Configure for static website hosting:
        # - Block public ACLs (security)
        # - Ignore public ACLs (security)
        # - Allow public policies (required for website)
        # - Allow public bucket access (required for website)
        aws s3api put-public-access-block \
          --bucket $BUCKET_NAME \
          --public-access-block-configuration \
          BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=false,RestrictPublicBuckets=false
        
        echo "âœ… Updated settings:"
        aws s3api get-public-access-block --bucket $BUCKET_NAME
        
        echo "âš ï¸  Security Note: Public policies are now allowed for static website hosting"
        echo "ðŸ›¡ï¸  ACL-based public access is still blocked for security"
    
    - name: ðŸŒ Configure S3 Static Website Hosting
      run: |
        BUCKET_NAME="$FRONTEND_BUCKET"
        
        # Configure bucket for static website hosting
        echo "ðŸŒ Configuring static website hosting..."
        aws s3 website s3://$BUCKET_NAME \
          --index-document index.html \
          --error-document index.html
        
        # Set bucket policy for public read access
        echo "ðŸ“œ Creating bucket policy for public read access..."
        cat > bucket-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "PublicReadGetObject",
              "Effect": "Allow",
              "Principal": "*",
              "Action": "s3:GetObject",
              "Resource": "arn:aws:s3:::$BUCKET_NAME/*"
            }
          ]
        }
        EOF
        
        echo "ðŸ”§ Applying bucket policy..."
        aws s3api put-bucket-policy \
          --bucket $BUCKET_NAME \
          --policy file://bucket-policy.json
        
        echo "âœ… Bucket policy applied successfully"
        
        # Get website endpoint
        WEBSITE_ENDPOINT="http://$BUCKET_NAME.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
        echo "ðŸŒ Website endpoint: $WEBSITE_ENDPOINT"
        echo "WEBSITE_ENDPOINT=$WEBSITE_ENDPOINT" >> $GITHUB_ENV
    
    - name: ðŸ§ª Test S3 Website Configuration
      run: |
        BUCKET_NAME="$FRONTEND_BUCKET"
        
        echo "ðŸ§ª Testing S3 website configuration..."
        
        # Verify bucket policy
        echo "ðŸ“‹ Verifying bucket policy:"
        aws s3api get-bucket-policy --bucket $BUCKET_NAME --query Policy --output text | jq .
        
        # Verify website configuration
        echo "ðŸŒ Verifying website configuration:"
        aws s3api get-bucket-website --bucket $BUCKET_NAME
        
        # Test endpoint accessibility (will fail until content is uploaded, but checks DNS)
        echo "ðŸ” Testing endpoint resolution:"
        nslookup "${BUCKET_NAME}.s3-website-${{ env.AWS_REGION }}.amazonaws.com" || echo "âš ï¸  DNS resolution test (expected to work after deployment)"
        
        echo "âœ… S3 website configuration validated"
    
    - name: âš¡ Setup Lambda execution role
      run: |
        ROLE_NAME="webapp-demo-lambda-execution-role"
        
        echo "ðŸ” Setting up Lambda execution role: $ROLE_NAME"
        
        # Check if role exists
        if aws iam get-role --role-name $ROLE_NAME >/dev/null 2>&1; then
          echo "âœ… Role already exists: $ROLE_NAME"
        else
          echo "ðŸ†• Creating Lambda execution role..."
          
          # Create trust policy
          cat > trust-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "lambda.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }
          EOF
          
          # Create role
          aws iam create-role \
            --role-name $ROLE_NAME \
            --assume-role-policy-document file://trust-policy.json
          
          # Attach basic execution policy
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          
          # Attach VPC access policy (for RDS access)
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
        fi
        
        ROLE_ARN=$(aws iam get-role --role-name $ROLE_NAME --query 'Role.Arn' --output text)
        echo "LAMBDA_ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV
        echo "âœ… Lambda role ARN: $ROLE_ARN"
    
    - name: ðŸŒ Setup VPC and Security Groups
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        VPC_NAME="webapp-demo-$ENVIRONMENT-vpc"
        
        echo "ðŸŒ Setting up VPC: $VPC_NAME"
        
        # Check if VPC exists
        VPC_ID=$(aws ec2 describe-vpcs \
          --filters "Name=tag:Name,Values=$VPC_NAME" \
          --query 'Vpcs[0].VpcId' \
          --output text 2>/dev/null || echo "None")
        
        if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
          echo "âœ… VPC already exists: $VPC_ID"
        else
          echo "ðŸ†• Creating VPC..."
          
          # Create VPC
          VPC_ID=$(aws ec2 create-vpc \
            --cidr-block 10.0.0.0/16 \
            --query 'Vpc.VpcId' \
            --output text)
          
          # Tag VPC
          aws ec2 create-tags \
            --resources $VPC_ID \
            --tags Key=Name,Value=$VPC_NAME
          
          # Create subnets
          SUBNET1_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.1.0/24 \
            --availability-zone ${AWS_REGION}a \
            --query 'Subnet.SubnetId' \
            --output text)
          
          SUBNET2_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.2.0/24 \
            --availability-zone ${AWS_REGION}b \
            --query 'Subnet.SubnetId' \
            --output text)
          
          # Tag subnets
          aws ec2 create-tags \
            --resources $SUBNET1_ID $SUBNET2_ID \
            --tags Key=Name,Value="$VPC_NAME-subnet"
        fi
        
        echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV
        echo "âœ… VPC configured: $VPC_ID"
    
    - name: ðŸ“‹ Generate infrastructure summary
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        
        cat > infrastructure-summary.md << EOF
        # ðŸ—ï¸ Infrastructure Setup Summary
        
        **Environment**: $ENVIRONMENT
        **Region**: ${{ env.AWS_REGION }}
        **Timestamp**: $(date)
        **Workflow Run**: ${{ github.run_id }}
        
        ## ðŸ“± Frontend Infrastructure
        - **S3 Bucket**: ${FRONTEND_BUCKET}
        - **Website URL**: ${WEBSITE_ENDPOINT}
        - **Block Public Access**: Configured for static website hosting
        - **Status**: âœ… Ready
        
        ## âš¡ Backend Infrastructure
        - **Lambda Role ARN**: ${LAMBDA_ROLE_ARN}
        - **VPC ID**: ${VPC_ID}
        - **Status**: âœ… Ready
        
        ## ðŸ” Security Configuration
        - **S3 Block Public Access**:
          - BlockPublicAcls: âœ… true (secure)
          - IgnorePublicAcls: âœ… true (secure)
          - BlockPublicPolicy: âŒ false (required for website)
          - RestrictPublicBuckets: âŒ false (required for website)
        - **Bucket Policy**: Public read access for website hosting
        
        ## ðŸ”„ Next Steps
        1. Run the database provisioning workflow
        2. Deploy your application using the main pipeline
        3. Configure monitoring and alerts
        4. Review security settings and add CloudFront if needed
        
        ## ðŸ’¡ Cost Optimization
        - S3 bucket configured for standard storage
        - Lambda cold starts minimized with provisioned concurrency (when needed)
        - VPC endpoints can be added to reduce NAT gateway costs
        
        ## ðŸ› ï¸ Troubleshooting
        If you encounter S3 Block Public Access errors:
        1. Check the S3 troubleshooting guide: docs/S3-TROUBLESHOOTING-GUIDE.md
        2. Verify IAM permissions include s3:PutPublicAccessBlock
        3. Review the bucket policy and Block Public Access settings
        
        EOF
        
        echo "âœ… Infrastructure setup completed successfully!"
        echo "ðŸ“„ Summary report generated: infrastructure-summary.md"
    
    - name: ðŸ’¾ Upload infrastructure artifacts
      uses: actions/upload-artifact@v4
      with:
        name: infrastructure-${{ github.event.inputs.environment }}-${{ github.run_id }}
        path: |
          infrastructure-summary.md
          *.json
        retention-days: 90
    
    - name: ðŸ“Š Display Summary
      run: |
        echo "" 
        echo "ðŸŽ‰ =================================="
        echo "âœ… INFRASTRUCTURE SETUP COMPLETE"
        echo "=================================="
        echo "ðŸ“± Website URL: $WEBSITE_ENDPOINT"
        echo "ðŸª£ S3 Bucket: $FRONTEND_BUCKET"
        echo "ðŸŒ VPC ID: $VPC_ID"
        echo "âš¡ Lambda Role: $LAMBDA_ROLE_ARN"
        echo "ðŸ“„ Full report available in artifacts"
        echo "=================================="