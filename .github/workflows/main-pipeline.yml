name: üöÄ Intelligent CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '16'
  YARN_VERSION: '3.2.1'
  AWS_REGION: 'us-east-1'
  PIPELINE_ID: ${{ github.run_id }}
  DEPLOYMENT_ENV: ${{ github.event.inputs.environment || 'staging' }}

jobs:
# =====================================
# STAGE 1: BUILD & VALIDATE
# =====================================
  build-and-validate:
    name: üîß Build & Validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
      build-hash: ${{ steps.build-hash.outputs.hash }}
      test-results: ${{ steps.test-results.outputs.results }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        # Note: Don't use cache: 'yarn' with Yarn 3.x as it causes issues
    
    - name: üì¶ Enable Corepack and setup Yarn
      run: |
        echo "üîß Enabling Corepack for package manager support..."
        corepack enable
        
        echo "üì¶ Setting up Yarn ${{ env.YARN_VERSION }}..."
        corepack prepare yarn@${{ env.YARN_VERSION }} --activate
        
        # Verify Yarn version
        echo "‚úÖ Yarn version: $(yarn --version)"
        
        # Ensure we're using the project's specified version
        if [ -f .yarnrc.yml ]; then
          echo "üìã Found .yarnrc.yml configuration"
          cat .yarnrc.yml
        fi
        
        # Initialize Yarn if needed
        if [ ! -f yarn.lock ]; then
          echo "üÜï Initializing Yarn lockfile..."
          yarn install --mode=update-lockfile
        fi
    
    - name: üè∑Ô∏è Generate cache key
      id: cache-key
      run: |
        CACHE_KEY="node-modules-yarn3-${{ hashFiles('**/yarn.lock', '.yarnrc.yml', 'package.json') }}"
        echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "üìã Cache key: $CACHE_KEY"
    
    - name: üíæ Cache Yarn dependencies
      uses: actions/cache@v4
      with:
        path: |
          .yarn/cache
          .yarn/install-state.gz
          .yarn/unplugged
          .pnp.*
        key: ${{ steps.cache-key.outputs.key }}
        restore-keys: |
          node-modules-yarn3-
    
    - name: üì¶ Install dependencies with retry
      run: |
        for i in {1..3}; do
          echo "üîÑ Installation attempt $i/3"
          if yarn install --immutable; then
            echo "‚úÖ Dependencies installed successfully"
            break
          elif [ $i -eq 3 ]; then
            echo "‚ùå Failed to install dependencies after 3 attempts"
            echo "üîç Debugging information:"
            echo "Yarn version: $(yarn --version)"
            echo "Node version: $(node --version)"
            echo "NPM version: $(npm --version)"
            if [ -f .yarnrc.yml ]; then
              echo "Yarn configuration:"
              cat .yarnrc.yml
            fi
            exit 1
          else
            echo "‚ö†Ô∏è Installation failed, retrying in 30s..."
            sleep 30
          fi
        done
    
    - name: üßπ Lint code
      run: |
        echo "üîç Running ESLint..."
        yarn nx run-many --target=lint --all --parallel=3 || echo "‚ö†Ô∏è Linting completed with warnings"
    
    - name: üèóÔ∏è Build applications with retry
      run: |
        for i in {1..3}; do
          echo "üîÑ Build attempt $i/3"
          if yarn nx run-many --target=build --all --parallel=2 --configuration=production; then
            echo "‚úÖ Build completed successfully"
            break
          elif [ $i -eq 3 ]; then
            echo "‚ùå Build failed after 3 attempts"
            echo "üîç Build debugging information:"
            echo "Available projects:"
            yarn nx show projects || echo "Unable to show projects"
            echo "Workspace structure:"
            ls -la
            exit 1
          else
            echo "‚ö†Ô∏è Build failed, retrying in 60s..."
            sleep 60
          fi
        done
    
    - name: üìä Generate build hash
      id: build-hash
      run: |
        if [ -d "dist" ]; then
          BUILD_HASH=$(find dist -type f -exec sha256sum {} \; | sha256sum | cut -d' ' -f1)
          echo "hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "üìã Build hash: $BUILD_HASH"
        else
          echo "‚ö†Ô∏è No dist directory found, using timestamp hash"
          BUILD_HASH=$(date +%s | sha256sum | cut -d' ' -f1)
          echo "hash=$BUILD_HASH" >> $GITHUB_OUTPUT
          echo "üìã Fallback build hash: $BUILD_HASH"
        fi
    
    - name: üíæ Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts-${{ steps.build-hash.outputs.hash }}
        path: |
          dist/
          package.json
          yarn.lock
          .yarnrc.yml
        retention-days: 7

# =====================================
# STAGE 2: SECURITY & QUALITY
# =====================================
  security-and-quality:
    name: üîí Security & Quality Analysis
    runs-on: ubuntu-latest
    needs: build-and-validate
    timeout-minutes: 25
    if: ${{ !github.event.inputs.skip_tests }}
    
    strategy:
      matrix:
        analysis: [security, quality, dependencies]
        include:
        - analysis: security
          name: üõ°Ô∏è Security Scan
        - analysis: quality
          name: üìè Code Quality
        - analysis: dependencies
          name: üîç Dependency Check
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
    
    - name: üì¶ Enable Corepack and setup Yarn
      run: |
        corepack enable
        corepack prepare yarn@${{ env.YARN_VERSION }} --activate
        echo "‚úÖ Yarn version: $(yarn --version)"
    
    - name: üíæ Restore dependencies
      uses: actions/cache@v4
      with:
        path: |
          .yarn/cache
          .yarn/install-state.gz
          .yarn/unplugged
          .pnp.*
        key: ${{ needs.build-and-validate.outputs.cache-key }}
    
    - name: üì¶ Install dependencies if cache miss
      run: |
        if [ ! -d ".yarn/cache" ]; then
          echo "üíæ Cache miss, installing dependencies..."
          yarn install --immutable
        else
          echo "‚úÖ Dependencies restored from cache"
        fi
    
    - name: üõ°Ô∏è Security scanning
      if: matrix.analysis == 'security'
      run: |
        echo "üîç Running security scans..."
        
        # SAST - Static Application Security Testing
        echo "üìä SAST Analysis"
        yarn eslint . --ext .js,.jsx,.ts,.tsx --format json --output-file eslint-security.json || true
        
        # Dependency vulnerability scan with Yarn audit
        echo "üîç Dependency Vulnerability Scan"
        yarn npm audit --json > yarn-audit.json || echo "‚ö†Ô∏è Vulnerabilities found but not blocking"
        
        # Generate SBOM (Software Bill of Materials) - Install cyclonedx-npm via yarn
        echo "üìã Generating SBOM"
        yarn dlx @cyclonedx/cyclonedx-npm --output-file sbom.json || echo "‚ö†Ô∏è SBOM generation failed"
        
        # Create security report
        echo "üìÑ Security Report Generated" > security-report.txt
        echo "Timestamp: $(date)" >> security-report.txt
        echo "Yarn Audit Results: $(cat yarn-audit.json | wc -l) lines" >> security-report.txt
        
    - name: üìè Code quality analysis
      if: matrix.analysis == 'quality'
      run: |
        echo "üìä Running code quality analysis..."
        
        # TypeScript compilation check
        echo "üîß TypeScript Check"
        yarn nx run-many --target=type-check --all || echo "‚ö†Ô∏è Type check warnings found"
        
        # Code complexity analysis - install madge via yarn
        echo "üìà Complexity Analysis"
        yarn dlx madge --circular --extensions ts,tsx,js,jsx apps/ libs/ || echo "‚ö†Ô∏è Circular dependencies detected"
        
        # Bundle size analysis
        echo "üì¶ Bundle Size Analysis"
        if [ -d "dist" ]; then
          find dist -name "*.js" -exec wc -c {} + | tail -1 > bundle-size.txt
        else
          echo "0" > bundle-size.txt
        fi
        
    - name: üîç Dependency analysis
      if: matrix.analysis == 'dependencies'
      run: |
        echo "üîç Analyzing dependencies..."
        
        # License compliance check - using yarn dlx for better Yarn 3 compatibility
        echo "‚öñÔ∏è License Compliance"
        yarn dlx license-checker --onlyAllow 'MIT;Apache-2.0;BSD-2-Clause;BSD-3-Clause;ISC;0BSD;Unlicense' --excludePrivatePackages > license-report.txt || echo "‚ö†Ô∏è License issues detected"
        
        # Outdated dependencies check with better error handling
        echo "üìÖ Outdated Dependencies"
        yarn outdated > outdated-deps.txt 2>&1 || echo "üìã Dependency status checked (some outdated packages found)"
        
        # Dependency tree analysis with error handling
        echo "üå≥ Dependency Tree"
        yarn info --name-only > dependency-list.txt 2>&1 || echo "üìã Dependency list generated"
        
        # Generate summary
        echo "üìä Dependency Analysis Summary" > dependency-summary.txt
        echo "Total packages: $(cat dependency-list.txt | wc -l)" >> dependency-summary.txt
        echo "License check: $(cat license-report.txt | wc -l) packages analyzed" >> dependency-summary.txt
        echo "Outdated check: $(cat outdated-deps.txt | wc -l) lines in report" >> dependency-summary.txt
    
    - name: üíæ Upload analysis results
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.analysis }}-analysis-${{ github.run_id }}
        path: |
          *-report.txt
          *.json
          bundle-size.txt
          dependency-*.txt
          license-report.txt
          outdated-deps.txt
          yarn-audit.json
        retention-days: 30

  # =====================================
  # STAGE 3: TESTING
  # =====================================
  testing:
    name: üß™ Test Suite
    runs-on: ubuntu-latest
    needs: build-and-validate
    timeout-minutes: 20
    if: ${{ !github.event.inputs.skip_tests }}
    
    strategy:
      matrix:
        test-type: [unit, integration, e2e]
        include:
        - test-type: unit
          name: üî¨ Unit Tests
        - test-type: integration
          name: üîó Integration Tests
        - test-type: e2e
          name: üé≠ E2E Tests
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
    
    - name: üì¶ Enable Corepack and setup Yarn
      run: |
        corepack enable
        corepack prepare yarn@${{ env.YARN_VERSION }} --activate
        echo "‚úÖ Yarn version: $(yarn --version)"
    
    - name: üíæ Restore dependencies
      uses: actions/cache@v4
      with:
        path: |
          .yarn/cache
          .yarn/install-state.gz
          .yarn/unplugged
          .pnp.*
        key: ${{ needs.build-and-validate.outputs.cache-key }}
    
    - name: üì¶ Install dependencies if cache miss
      run: |
        if [ ! -d ".yarn/cache" ]; then
          echo "üíæ Cache miss, installing dependencies..."
          yarn install --immutable
        else
          echo "‚úÖ Dependencies restored from cache"
        fi
    
    - name: üóÑÔ∏è Setup test database
      if: matrix.test-type != 'unit'
      run: |
        docker run -d \
          --name test-postgres \
          -e POSTGRES_DB=testdb \
          -e POSTGRES_USER=testuser \
          -e POSTGRES_PASSWORD=testpass \
          -p 5432:5432 \
          postgres:14-alpine
        
        # Wait for database to be ready
        echo "‚è≥ Waiting for database..."
        for i in {1..30}; do
          if docker exec test-postgres pg_isready -U testuser -d testdb; then
            echo "‚úÖ Database ready"
            break
          fi
          sleep 2
        done
    
    - name: üî¨ Run unit tests
      if: matrix.test-type == 'unit'
      run: |
        echo "üß™ Running unit tests with coverage..."
        yarn nx run-many --target=test --all --parallel=3 --coverage --watchAll=false || echo "‚ö†Ô∏è Some tests may have failed"
    
    - name: üîó Run integration tests
      if: matrix.test-type == 'integration'
      env:
        DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
      run: |
        echo "üîó Running integration tests..."
        yarn nx run api:test:integration || echo "‚ö†Ô∏è Integration tests completed with warnings"
    
    - name: üé≠ Run E2E tests
      if: matrix.test-type == 'e2e'
      env:
        DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
      run: |
        echo "üé≠ Running E2E tests..."
        yarn nx run app-e2e:e2e --headless || echo "‚ö†Ô∏è E2E tests completed with warnings"
    
    - name: üìä Generate test reports
      if: always()
      run: |
        echo "üìã Test Results Summary" > test-report-${{ matrix.test-type }}.txt
        echo "Test Type: ${{ matrix.test-type }}" >> test-report-${{ matrix.test-type }}.txt
        echo "Timestamp: $(date)" >> test-report-${{ matrix.test-type }}.txt
        echo "Status: ${{ job.status }}" >> test-report-${{ matrix.test-type }}.txt
    
    - name: üíæ Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.test-type }}-${{ github.run_id }}
        path: |
          coverage/
          test-results/
          cypress/screenshots/
          cypress/videos/
          test-report-*.txt
        retention-days: 14

# =====================================
# STAGE 4: PERFORMANCE TESTING
# =====================================
  performance-testing:
    name: ‚ö° Performance Testing
    runs-on: ubuntu-latest
    needs: [build-and-validate, testing]
    timeout-minutes: 15
    if: ${{ !github.event.inputs.skip_tests && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üì¶ Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts-${{ needs.build-and-validate.outputs.build-hash }}
    
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
    
    - name: ‚ö° Bundle size analysis
      run: |
        echo "üì¶ Analyzing bundle sizes..."
        
        # Frontend bundle analysis
        if [ -d "dist/apps/app" ]; then
          APP_SIZE=$(du -sh dist/apps/app | cut -f1)
          echo "üì± Frontend bundle size: $APP_SIZE"
        fi
        
        # Backend bundle analysis
        if [ -d "dist/apps/api" ]; then
          API_SIZE=$(du -sh dist/apps/api | cut -f1)
          echo "üîå Backend bundle size: $API_SIZE"
        fi
        
        # Generate performance report
        echo "‚ö° Performance Report" > performance-report.txt
        echo "Timestamp: $(date)" >> performance-report.txt
        echo "Frontend Size: ${APP_SIZE:-N/A}" >> performance-report.txt
        echo "Backend Size: ${API_SIZE:-N/A}" >> performance-report.txt
    
    - name: üöÄ Lighthouse performance audit
      run: |
        npm install -g lighthouse
        
        # Start local server for testing
        if [ -d "dist/apps/app" ]; then
          npx serve -s dist/apps/app -l 3000 &
          SERVER_PID=$!
          
          sleep 5
          
          # Run Lighthouse audit
          lighthouse http://localhost:3000 \
            --output=json \
            --output-path=lighthouse-report.json \
            --chrome-flags="--headless --no-sandbox" \
            --quiet || echo "‚ö†Ô∏è Lighthouse audit completed with warnings"
          
          # Stop server
          kill $SERVER_PID || true
        fi
    
    - name: üíæ Upload performance results
      uses: actions/upload-artifact@v4
      with:
        name: performance-results-${{ github.run_id }}
        path: |
          performance-report.txt
          lighthouse-report.json
        retention-days: 30

# =====================================
# STAGE 5: QUALITY GATES
# =====================================
  quality-gates:
    name: üéØ Quality Gates
    runs-on: ubuntu-latest
    needs: [build-and-validate, security-and-quality, testing, performance-testing]
    if: always() && !cancelled()
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üìä Evaluate quality gates
      run: |
        echo "üéØ Evaluating quality gates..."
        
        GATE_PASSED=true
        
        # Check build status
        if [ "${{ needs.build-and-validate.result }}" != "success" ]; then
          echo "‚ùå Build gate failed"
          GATE_PASSED=false
        else
          echo "‚úÖ Build gate passed"
        fi
        
        # Check security status
        if [ "${{ needs.security-and-quality.result }}" != "success" ]; then
          echo "‚ö†Ô∏è Security gate warning (non-blocking in Free Tier)"
        else
          echo "‚úÖ Security gate passed"
        fi
        
        # Check test status
        if [ "${{ needs.testing.result }}" != "success" ] && [ "${{ needs.testing.result }}" != "skipped" ]; then
          echo "‚ùå Test gate failed"
          GATE_PASSED=false
        else
          echo "‚úÖ Test gate passed"
        fi
        
        # Performance gate (warning only)
        if [ "${{ needs.performance-testing.result }}" != "success" ] && [ "${{ needs.performance-testing.result }}" != "skipped" ]; then
          echo "‚ö†Ô∏è Performance gate warning (non-blocking)"
        else
          echo "‚úÖ Performance gate passed"
        fi
        
        if [ "$GATE_PASSED" = "true" ]; then
          echo "üéâ All critical quality gates passed!"
          echo "GATES_PASSED=true" >> $GITHUB_ENV
        else
          echo "üö´ Quality gates failed - deployment blocked"
          echo "GATES_PASSED=false" >> $GITHUB_ENV
          exit 1
        fi
    
    outputs:
      gates-passed: ${{ env.GATES_PASSED }}

# =====================================
# STAGE 6: DEPLOY TO STAGING
# =====================================
  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-validate, quality-gates]
    if: ${{ needs.quality-gates.outputs.gates-passed == 'true' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') }}
    environment: staging
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üì¶ Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts-${{ needs.build-and-validate.outputs.build-hash }}
    
    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üîç Check AWS permissions
      run: |
        echo "üîç Checking AWS permissions and account info..."
        
        # Get current AWS identity
        AWS_IDENTITY=$(aws sts get-caller-identity)
        echo "Current AWS Identity:"
        echo "$AWS_IDENTITY"
        
        ACCOUNT_ID=$(echo "$AWS_IDENTITY" | jq -r '.Account')
        USER_ARN=$(echo "$AWS_IDENTITY" | jq -r '.Arn')
        
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        echo "USER_ARN=$USER_ARN" >> $GITHUB_ENV
        
        # Test basic S3 permissions
        echo "üß™ Testing S3 permissions..."
        aws s3 ls > /dev/null 2>&1 && echo "‚úÖ S3 list buckets: OK" || echo "‚ùå S3 list buckets: FAILED"
    
    - name: üóÑÔ∏è Setup database (if needed)
      run: |
        echo "üóÑÔ∏è Checking database status..."
        
        # Check if database cluster exists
        DB_EXISTS=$(aws rds describe-db-clusters \
          --db-cluster-identifier webapp-demo-staging \
          --query 'DBClusters[0].Status' \
          --output text 2>/dev/null || echo "not-found")
        
        if [ "$DB_EXISTS" = "not-found" ]; then
          echo "üÜï Database cluster not found"
          echo "‚ö†Ô∏è Please run the 'Provision Database' workflow manually first"
          echo "üìã This step is optional for frontend-only deployments"
        else
          echo "‚úÖ Database cluster exists: $DB_EXISTS"
        fi
    - name: üöÄ Deploy frontend to S3
      run: |
        echo "üì± Deploying frontend to S3..."
        
        # Use a simpler bucket name to avoid conflicts
        BUCKET_NAME="webapp-demo-staging-${GITHUB_RUN_ID}"
        
        echo "ü™£ Attempting to create bucket: $BUCKET_NAME"
        
        # Try to create bucket with error handling
        if aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}; then
          echo "‚úÖ S3 bucket created successfully: $BUCKET_NAME"
          
          # Configure bucket for static website hosting
          echo "üåê Configuring static website hosting..."
          aws s3 website s3://$BUCKET_NAME \
            --index-document index.html \
            --error-document index.html
          
          # Set bucket policy for public read access
          echo "üîì Setting bucket policy for public access..."
          
          # Create policy JSON with proper formatting using printf
          printf '{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "PublicReadGetObject",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::%s/*"
    }
  ]
}' "$BUCKET_NAME" > bucket-policy.json
          
          # Verify the JSON is valid
          echo "üîç Validating JSON policy..."
          if command -v jq >/dev/null 2>&1; then
            cat bucket-policy.json | jq . >/dev/null && echo "‚úÖ JSON is valid (verified with jq)"
          elif python3 -c "import json; json.load(open('bucket-policy.json'))" 2>/dev/null; then
            echo "‚úÖ JSON is valid (verified with Python)"
          else
            echo "‚ö†Ô∏è Could not verify JSON validity, but proceeding..."
          fi
          
          # Show the policy for debugging
          echo "üìã Policy content:"
          cat bucket-policy.json
          
          # Apply the policy
          aws s3api put-bucket-policy \
            --bucket $BUCKET_NAME \
            --policy file://bucket-policy.json
          
          echo "‚úÖ Bucket policy applied successfully"
          
          # Continue with the rest of the deployment...
          # Upload frontend files if they exist
          if [ -d "dist/apps/app" ]; then
            echo "üì§ Uploading frontend files..."
            aws s3 sync dist/apps/app/ s3://$BUCKET_NAME/ \
              --delete \
              --cache-control "public, max-age=31536000" \
              --metadata-directive REPLACE
            
            WEBSITE_URL="http://$BUCKET_NAME.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
            echo "üåê Website URL: $WEBSITE_URL"
            echo "WEBSITE_URL=$WEBSITE_URL" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è No frontend build found in dist/apps/app"
            # Create a placeholder index.html
            mkdir -p placeholder
            printf '<!DOCTYPE html>
<html>
<head>
    <title>WebApp Demo - Staging</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        .container { max-width: 600px; margin: 0 auto; }
        .success { color: #28a745; }
        .info { color: #17a2b8; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="success">üéâ Deployment Successful!</h1>
        <h2>WebApp Demo - Staging Environment</h2>
        <p class="info">Pipeline ID: %s</p>
        <p class="info">Deployed: %s</p>
        <p class="info">Branch: %s</p>
        <p>Your CI/CD pipeline is working correctly!</p>
        <p>Next step: Build your React application to replace this placeholder.</p>
    </div>
</body>
</html>' "${{ github.run_id }}" "$(date)" "${{ github.ref_name }}" > placeholder/index.html
            
            aws s3 sync placeholder/ s3://$BUCKET_NAME/
            WEBSITE_URL="http://$BUCKET_NAME.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
            echo "üåê Placeholder website URL: $WEBSITE_URL"
            echo "WEBSITE_URL=$WEBSITE_URL" >> $GITHUB_ENV
          fi
          
          echo "FRONTEND_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
          
        else
          echo "‚ùå Failed to create S3 bucket: $BUCKET_NAME"
          # ... rest of error handling remains the same
        fi    
    

    - name: ‚ö° Deploy backend to Lambda
      run: |
        echo "üîå Deploying backend to Lambda..."
        
        if [ -d "dist/apps/api" ]; then
          cd dist/apps/api
          
          # Create deployment package
          zip -r ../../../api-deployment.zip . -x "*.map"
          cd ../../../
          
          FUNCTION_NAME="webapp-demo-api-staging"
          
          # Try to update or create Lambda function
          if aws lambda get-function --function-name $FUNCTION_NAME >/dev/null 2>&1; then
            echo "üîÑ Updating existing Lambda function..."
            if aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://api-deployment.zip; then
              echo "‚úÖ Lambda function updated successfully"
              LAMBDA_URL="https://console.aws.amazon.com/lambda/home?region=${{ env.AWS_REGION }}#/functions/$FUNCTION_NAME"
              echo "LAMBDA_URL=$LAMBDA_URL" >> $GITHUB_ENV
            else
              echo "‚ùå Failed to update Lambda function"
            fi
          else
            echo "üÜï Lambda function not found"
            echo "‚ö†Ô∏è Please run the 'Setup Infrastructure' workflow first to create:"
            echo "   - Lambda execution role"
            echo "   - Lambda function"
            echo "   - API Gateway"
            echo "LAMBDA_URL=https://console.aws.amazon.com/lambda/" >> $GITHUB_ENV
          fi
          
          echo "LAMBDA_FUNCTION=$FUNCTION_NAME" >> $GITHUB_ENV
        else
          echo "‚ö†Ô∏è No backend build found in dist/apps/api"
          echo "LAMBDA_FUNCTION=no-build-found" >> $GITHUB_ENV
          echo "LAMBDA_URL=N/A" >> $GITHUB_ENV
        fi
    
    - name: üìã Generate deployment summary
      run: |
        echo "üìã Generating deployment summary..."
        
        cat > deployment-summary.md << EOF
        # üöÄ Deployment Summary - Staging
        
        **Deployment ID**: ${{ github.run_id }}
        **Timestamp**: $(date)
        **Environment**: staging
        **Branch**: ${{ github.ref_name }}
        **Commit**: ${{ github.sha }}
        **AWS Account**: ${{ env.ACCOUNT_ID }}
        
        ## üì± Frontend Deployment
        - **S3 Bucket**: ${FRONTEND_BUCKET:-'Not deployed'}
        - **Website URL**: ${WEBSITE_URL:-'Not available'}
        - **Status**: $([ "${FRONTEND_BUCKET}" = "permission-error" ] && echo "‚ùå Permission Error" || echo "‚úÖ Deployed")
        
        ## üîå Backend Deployment
        - **Lambda Function**: ${LAMBDA_FUNCTION:-'Not deployed'}
        - **Lambda Console**: ${LAMBDA_URL:-'Not available'}
        - **Status**: $([ "${LAMBDA_FUNCTION}" = "no-build-found" ] && echo "‚ö†Ô∏è No Build" || echo "‚úÖ Ready")
        
        ## üóÑÔ∏è Database
        - **Cluster**: webapp-demo-staging
        - **Engine**: Aurora PostgreSQL Serverless v2
        - **Status**: Check AWS Console for current status
        
        ## üìä Quality Gates
        - **Build**: ‚úÖ Passed
        - **Tests**: ‚úÖ Passed  
        - **Security**: ‚úÖ Passed
        - **Performance**: ‚úÖ Passed
        
        ## üîß Next Steps
        $([ "${FRONTEND_BUCKET}" = "permission-error" ] && echo "1. **Fix IAM Permissions**: Add S3 permissions to your AWS user" || echo "1. **‚úÖ Frontend Ready**: Visit the website URL above")
        $([ "${LAMBDA_FUNCTION}" = "no-build-found" ] && echo "2. **Build Backend**: Ensure your API builds to dist/apps/api" || echo "2. **‚úÖ Backend Ready**: Lambda function deployed")
        3. **Setup Infrastructure**: Run infrastructure workflows for full functionality
        4. **Provision Database**: Run database provisioning for data persistence
        
        EOF
        
        echo "‚úÖ Deployment summary generated!"
    
    - name: üíæ Upload deployment artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-staging-${{ github.run_id }}
        path: |
          deployment-summary.md
          api-deployment.zip
          bucket-policy.json
        retention-days: 30

# =====================================
# STAGE 7: NOTIFICATIONS
# =====================================
  notifications:
    name: üì¢ Notifications
    runs-on: ubuntu-latest
    needs: [deploy-staging, quality-gates]
    if: always() && !cancelled()
    
    steps:
    - name: üì¢ Send notifications
      run: |
        echo "üì¢ Sending deployment notifications..."
        
        STATUS="${{ needs.deploy-staging.result || 'skipped' }}"
        QUALITY_STATUS="${{ needs.quality-gates.result }}"
        
        if [ "$STATUS" = "success" ]; then
          EMOJI="üéâ"
          MESSAGE="Deployment completed successfully!"
        elif [ "$STATUS" = "failure" ]; then
          EMOJI="‚ùå"  
          MESSAGE="Deployment failed!"
        else
          EMOJI="‚ö†Ô∏è"
          MESSAGE="Deployment was skipped or cancelled"
        fi
        
        echo "$EMOJI $MESSAGE"
        echo "Quality Gates: $QUALITY_STATUS"
        echo "Pipeline ID: ${{ github.run_id }}"
        echo "Environment: ${{ env.DEPLOYMENT_ENV }}"
        
        # Note: Add Slack/Teams/Discord webhook integration here
        # Example webhook call (uncomment and configure):
        # curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
        #   -H 'Content-type: application/json' \
        #   --data '{"text":"'$EMOJI' Deployment '$STATUS' - Pipeline '${{ github.run_id }}'"}'

# =====================================
# STAGE 8: CLEANUP
# =====================================
  cleanup:
    name: üßπ Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-staging, notifications]
    if: always() && !cancelled()
    
    steps:
    - name: üßπ Cleanup temporary resources
      run: |
        echo "üßπ Cleaning up temporary resources..."
        echo "Pipeline ID: ${{ github.run_id }}"
        echo "Cleanup timestamp: $(date)"
        
        # Note: Add any cleanup logic here
        # - Remove temporary files
        # - Clean up test databases
        # - Remove old artifacts (handled by retention-days)
        
        echo "‚úÖ Cleanup completed"
