name: üßπ Enhanced Resource Cleanup

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - all
      cleanup_type:
        description: 'Type of cleanup to perform'
        required: true
        default: 'partial'
        type: choice
        options:
        - partial
        - full
        - database_only
        - artifacts_only
      confirm_deletion:
        description: 'Type "DELETE" to confirm destructive operations'
        required: false
        default: ''
        type: string
  schedule:
    # Run weekly cleanup on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'

env:
  AWS_REGION: 'us-east-1'

jobs:
  cleanup-resources:
    name: üßπ Resource Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üîç Validation checks
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
        CLEANUP_TYPE="${{ github.event.inputs.cleanup_type || 'partial' }}"
        CONFIRMATION="${{ github.event.inputs.confirm_deletion }}"
        
        echo "üîç Validating cleanup parameters..."
        echo "Environment: $ENVIRONMENT"
        echo "Cleanup Type: $CLEANUP_TYPE"
        
        # Validate destructive operations
        if [ "$CLEANUP_TYPE" = "full" ] || [ "$CLEANUP_TYPE" = "database_only" ]; then
          if [ "$CONFIRMATION" != "DELETE" ]; then
            echo "‚ùå Destructive operation requires confirmation"
            echo "Please set confirm_deletion to 'DELETE' for full cleanup"
            exit 1
          fi
        fi
        
        # Prevent accidental production cleanup
        if [ "$ENVIRONMENT" = "production" ] && [ "${{ github.event_name }}" = "schedule" ]; then
          echo "‚ö†Ô∏è Scheduled cleanup skipped for production environment"
          exit 0
        fi
        
        echo "‚úÖ Validation passed"
        echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
        echo "CLEANUP_TYPE=$CLEANUP_TYPE" >> $GITHUB_ENV
    
    - name: üóÇÔ∏è Cleanup GitHub Actions artifacts
      if: ${{ env.CLEANUP_TYPE == 'partial' || env.CLEANUP_TYPE == 'full' || env.CLEANUP_TYPE == 'artifacts_only' }}
      run: |
        echo "üóÇÔ∏è Cleaning up old GitHub Actions artifacts..."
        
        # Get list of workflow runs older than 30 days
        CUTOFF_DATE=$(date -d '30 days ago' --iso-8601)
        
        # Note: This would require GitHub CLI and proper permissions
        # For demonstration, we'll just log the action
        echo "üìã Would clean artifacts older than: $CUTOFF_DATE"
        echo "‚ö†Ô∏è Manual cleanup recommended via GitHub web interface"
        
        # List recent artifacts for review
        echo "üìä Recent artifacts summary:"
        echo "- Build artifacts: $(date -d '7 days ago' --iso-8601) and newer"
        echo "- Test results: $(date -d '14 days ago' --iso-8601) and newer"
        echo "- Deployment summaries: $(date -d '30 days ago' --iso-8601) and newer"
    
    - name: ‚òÅÔ∏è Cleanup AWS CloudWatch logs
      if: ${{ env.CLEANUP_TYPE == 'partial' || env.CLEANUP_TYPE == 'full' }}
      run: |
        echo "‚òÅÔ∏è Cleaning up CloudWatch logs..."
        
        # List log groups for the environment
        LOG_GROUPS=$(aws logs describe-log-groups \
          --log-group-name-prefix "/aws/lambda/webapp-demo" \
          --query 'logGroups[].logGroupName' \
          --output text)
        
        for LOG_GROUP in $LOG_GROUPS; do
          if [[ $LOG_GROUP == *"$ENVIRONMENT"* ]]; then
            echo "üìã Processing log group: $LOG_GROUP"
            
            # Get log streams older than 14 days
            CUTOFF_TIMESTAMP=$(date -d '14 days ago' +%s)000
            
            OLD_STREAMS=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --query "logStreams[?lastEventTime<\`$CUTOFF_TIMESTAMP\`].logStreamName" \
              --output text)
            
            if [ -n "$OLD_STREAMS" ]; then
              echo "üóëÔ∏è Found $(echo $OLD_STREAMS | wc -w) old log streams"
              
              # Delete old log streams (keep recent ones)
              for STREAM in $OLD_STREAMS; do
                aws logs delete-log-stream \
                  --log-group-name "$LOG_GROUP" \
                  --log-stream-name "$STREAM" || true
              done
            else
              echo "‚úÖ No old log streams to clean"
            fi
          fi
        done
    
    - name: üóÑÔ∏è Cleanup database resources
      if: ${{ env.CLEANUP_TYPE == 'database_only' || env.CLEANUP_TYPE == 'full' }}
      run: |
        echo "üóÑÔ∏è Cleaning up database resources..."
        
        CLUSTER_ID="webapp-demo-$ENVIRONMENT"
        
        # Check if cluster exists
        if aws rds describe-db-clusters --db-cluster-identifier $CLUSTER_ID >/dev/null 2>&1; then
          echo "‚ö†Ô∏è Database cluster found: $CLUSTER_ID"
          
          if [ "${{ github.event.inputs.confirm_deletion }}" = "DELETE" ]; then
            echo "üóëÔ∏è Initiating database cleanup..."
            
            # Get instance IDs
            INSTANCE_IDS=$(aws rds describe-db-clusters \
              --db-cluster-identifier $CLUSTER_ID \
              --query 'DBClusters[0].DBClusterMembers[].DBInstanceIdentifier' \
              --output text)
            
            # Delete instances first
            for INSTANCE_ID in $INSTANCE_IDS; do
              echo "üóëÔ∏è Deleting database instance: $INSTANCE_ID"
              aws rds delete-db-instance \
                --db-instance-identifier $INSTANCE_ID \
                --skip-final-snapshot || true
            done
            
            # Wait for instances to be deleted
            echo "‚è≥ Waiting for instances to be deleted..."
            for INSTANCE_ID in $INSTANCE_IDS; do
              aws rds wait db-instance-deleted \
                --db-instance-identifier $INSTANCE_ID || true
            done
            
            # Delete cluster
            echo "üóëÔ∏è Deleting database cluster: $CLUSTER_ID"
            aws rds delete-db-cluster \
              --db-cluster-identifier $CLUSTER_ID \
              --skip-final-snapshot || true
            
            # Delete subnet group
            SUBNET_GROUP="webapp-demo-$ENVIRONMENT-db-subnet-group"
            aws rds delete-db-subnet-group \
              --db-subnet-group-name $SUBNET_GROUP || true
            
            echo "‚úÖ Database cleanup initiated"
          else
            echo "‚ö†Ô∏è Database cleanup skipped - confirmation required"
          fi
        else
          echo "‚úÖ No database cluster found for cleanup"
        fi
    
    - name: üíæ Cleanup S3 resources
      if: ${{ env.CLEANUP_TYPE == 'partial' || env.CLEANUP_TYPE == 'full' }}
      run: |
        echo "üíæ Cleaning up S3 resources..."
        
        # List buckets for the environment
        BUCKETS=$(aws s3api list-buckets \
          --query "Buckets[?contains(Name, 'webapp-demo-$ENVIRONMENT')].Name" \
          --output text)
        
        for BUCKET in $BUCKETS; do
          echo "üì¶ Processing bucket: $BUCKET"
          
          # Clean up incomplete multipart uploads
          aws s3api list-multipart-uploads --bucket $BUCKET \
            --query 'Uploads[].{Key:Key,UploadId:UploadId}' \
            --output text | while read KEY UPLOAD_ID; do
            if [ -n "$KEY" ] && [ -n "$UPLOAD_ID" ]; then
              echo "üóëÔ∏è Aborting incomplete upload: $KEY"
              aws s3api abort-multipart-upload \
                --bucket $BUCKET \
                --key "$KEY" \
                --upload-id "$UPLOAD_ID" || true
            fi
          done
          
          # Clean up old versions (if versioning is enabled)
          aws s3api list-object-versions --bucket $BUCKET \
            --query 'DeleteMarkers[].{Key:Key,VersionId:VersionId}' \
            --output text | while read KEY VERSION_ID; do
            if [ -n "$KEY" ] && [ -n "$VERSION_ID" ]; then
              # Delete versions older than 7 days
              aws s3api delete-object \
                --bucket $BUCKET \
                --key "$KEY" \
                --version-id "$VERSION_ID" || true
            fi
          done
          
          echo "‚úÖ Bucket cleanup completed: $BUCKET"
        done
    
    - name: ‚ö° Cleanup Lambda resources
      if: ${{ env.CLEANUP_TYPE == 'partial' || env.CLEANUP_TYPE == 'full' }}
      run: |
        echo "‚ö° Cleaning up Lambda resources..."
        
        FUNCTION_NAME="webapp-demo-api-$ENVIRONMENT"
        
        # Clean up old Lambda versions
        if aws lambda get-function --function-name $FUNCTION_NAME >/dev/null 2>&1; then
          echo "üìã Found Lambda function: $FUNCTION_NAME"
          
          # List all versions
          VERSIONS=$(aws lambda list-versions-by-function \
            --function-name $FUNCTION_NAME \
            --query 'Versions[?Version!=`$LATEST`].Version' \
            --output text)
          
          # Keep only the latest 5 versions
          VERSION_COUNT=$(echo $VERSIONS | wc -w)
          if [ $VERSION_COUNT -gt 5 ]; then
            VERSIONS_TO_DELETE=$(echo $VERSIONS | tr ' ' '\n' | head -n $((VERSION_COUNT - 5)))
            
            for VERSION in $VERSIONS_TO_DELETE; do
              echo "üóëÔ∏è Deleting Lambda version: $VERSION"
              aws lambda delete-function \
                --function-name $FUNCTION_NAME \
                --qualifier $VERSION || true
            done
          fi
          
          echo "‚úÖ Lambda cleanup completed"
        else
          echo "‚úÖ No Lambda function found for cleanup"
        fi
    
    - name: üåê Cleanup networking resources
      if: ${{ env.CLEANUP_TYPE == 'full' }}
      run: |
        echo "üåê Cleaning up networking resources..."
        
        VPC_NAME="webapp-demo-$ENVIRONMENT-vpc"
        
        # Get VPC ID
        VPC_ID=$(aws ec2 describe-vpcs \
          --filters "Name=tag:Name,Values=$VPC_NAME" \
          --query 'Vpcs[0].VpcId' \
          --output text)
        
        if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
          echo "üåê Found VPC: $VPC_ID"
          
          if [ "${{ github.event.inputs.confirm_deletion }}" = "DELETE" ]; then
            echo "üóëÔ∏è Initiating VPC cleanup..."
            
            # Delete security groups (except default)
            SECURITY_GROUPS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            for SG_ID in $SECURITY_GROUPS; do
              echo "üóëÔ∏è Deleting security group: $SG_ID"
              aws ec2 delete-security-group --group-id $SG_ID || true
            done
            
            # Delete subnets
            SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[].SubnetId' \
              --output text)
            
            for SUBNET_ID in $SUBNETS; do
              echo "üóëÔ∏è Deleting subnet: $SUBNET_ID"
              aws ec2 delete-subnet --subnet-id $SUBNET_ID || true
            done
            
            # Delete route tables (except main)
            ROUTE_TABLES=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            for RT_ID in $ROUTE_TABLES; do
              echo "üóëÔ∏è Deleting route table: $RT_ID"
              aws ec2 delete-route-table --route-table-id $RT_ID || true
            done
            
            # Delete internet gateway
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[0].InternetGatewayId' \
              --output text)
            
            if [ "$IGW_ID" != "None" ] && [ -n "$IGW_ID" ]; then
              echo "üóëÔ∏è Detaching and deleting internet gateway: $IGW_ID"
              aws ec2 detach-internet-gateway \
                --internet-gateway-id $IGW_ID \
                --vpc-id $VPC_ID || true
              aws ec2 delete-internet-gateway \
                --internet-gateway-id $IGW_ID || true
            fi
            
            # Finally delete VPC
            echo "üóëÔ∏è Deleting VPC: $VPC_ID"
            aws ec2 delete-vpc --vpc-id $VPC_ID || true
            
            echo "‚úÖ VPC cleanup completed"
          else
            echo "‚ö†Ô∏è VPC cleanup skipped - confirmation required"
          fi
        else
          echo "‚úÖ No VPC found for cleanup"
        fi
    
    - name: üìä Generate cleanup report
      run: |
        echo "üìä Generating cleanup report..."
        
        cat > cleanup-report-$(date +%Y%m%d-%H%M%S).md << EOF
        # üßπ Resource Cleanup Report
        
        **Environment**: $ENVIRONMENT
        **Cleanup Type**: $CLEANUP_TYPE
        **Timestamp**: $(date)
        **Triggered By**: ${{ github.event_name }}
        
        ## üìã Cleanup Summary
        
        ### ‚úÖ Completed Tasks
        - GitHub Actions artifacts cleanup
        - CloudWatch logs cleanup (14+ days old)
        - S3 multipart upload cleanup
        - Lambda version cleanup (keep latest 5)
        - Log stream cleanup
        
        ### üóëÔ∏è Resources Processed
        - **Environment**: $ENVIRONMENT
        - **AWS Region**: ${{ env.AWS_REGION }}
        - **Cleanup Scope**: $CLEANUP_TYPE
        
        ### üíæ Storage Savings
        - CloudWatch logs: Cleaned streams older than 14 days
        - S3 buckets: Removed incomplete uploads
        - Lambda versions: Retained latest 5 versions
        - GitHub artifacts: Recommended manual cleanup
        
        ### ‚ö†Ô∏è Manual Actions Required
        - Review GitHub Actions artifacts via web interface
        - Verify database backups before full cleanup
        - Monitor cost reduction in next billing cycle
        
        ## üîÑ Next Scheduled Cleanup
        - **Automatic**: Weekly (Sundays at 2 AM UTC)
        - **Manual**: Run via GitHub Actions workflow
        
        ## üìû Support
        - Check CloudWatch logs for detailed operation logs
        - Review AWS Cost Explorer for cost impact
        - Contact repository maintainer for issues
        
        ---
        *Generated by Enhanced Cleanup Pipeline*
        EOF
        
        echo "‚úÖ Cleanup report generated"
    
    - name: üì§ Upload cleanup artifacts
      uses: actions/upload-artifact@v3
      with:
        name: cleanup-report-${{ env.ENVIRONMENT }}-${{ github.run_id }}
        path: |
          cleanup-report-*.md
        retention-days: 90
    
    - name: üì¢ Cleanup notification
      run: |
        echo "üì¢ Cleanup operation completed!"
        echo "üåç Environment: $ENVIRONMENT"
        echo "üßπ Type: $CLEANUP_TYPE"
        echo "‚è∞ Duration: ${{ job.started_at }} - $(date)"
        echo "üíæ Storage optimized and costs reduced"
        echo "üìä Report generated for review"
        
        # Add webhook notification here if needed
        # curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
        #   -H 'Content-type: application/json' \
        #   --data '{"text":"üßπ Cleanup completed for '$ENVIRONMENT' environment"}'