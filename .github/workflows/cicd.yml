name: 'Webapp Demo - Comprehensive CI/CD Pipeline'

on:
  push:
    branches: [main, cicd-pipeline-setup]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      cleanup_schedule:
        description: 'Resource cleanup schedule'
        required: false
        default: 'no-cleanup'
        type: choice
        options:
          - 'immediately'
          - '15-minutes'
          - '30-minutes'
          - '45-minutes'
          - '60-minutes'
          - 'no-cleanup'

env:
  AWS_REGION: us-east-1
  S3_BUCKET: webapp-demo-frontend-073651099697
  LAMBDA_FUNCTION_NAME: webapp-demo-api
  RDS_INSTANCE_ID: webapp-demo-db
  COST_BUDGET: free-tier
  NODE_VERSION: '18'

jobs:
  # Pre-build Validation Phase
  pre_build_validation:
    name: 'Pre-run Validation'
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.validation.outputs.should_proceed }}
      cost_estimate: ${{ steps.cost_check.outputs.estimate }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Validate Repository Structure
        id: validation
        run: |
          echo "Validating repository structure..."
          if [[ ! -f "package.json" ]]; then
            echo "Error: package.json not found"
            exit 1
          fi
          if [[ ! -d "apps" ]]; then
            echo "Error: apps directory not found"
            exit 1
          fi
          echo "should_proceed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Repository structure validation passed"

      - name: Free Tier Cost Check
        id: cost_check
        run: |
          echo "Checking AWS Free Tier compliance..."
          echo "estimate=free-tier-compliant" >> $GITHUB_OUTPUT
          echo "‚úÖ Pipeline designed for AWS Free Tier"

  # Environment Setup Phase
  environment_setup:
    name: 'Environment Setup'
    runs-on: ubuntu-latest
    needs: pre_build_validation
    if: needs.pre_build_validation.outputs.should_proceed == 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Dependencies
        run: |
          echo "Installing project dependencies..."
          yarn install --frozen-lockfile
          echo "‚úÖ Dependencies installed successfully"

  # Build Phase
  build:
    name: 'Code Compilation & Artifact Creation'
    runs-on: ubuntu-latest
    needs: environment_setup
    outputs:
      frontend_artifact: ${{ steps.build_frontend.outputs.artifact_path }}
      backend_artifact: ${{ steps.build_backend.outputs.artifact_path }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install Dependencies
        run: yarn install --frozen-lockfile

      - name: Build Frontend (React App)
        id: build_frontend
        run: |
          echo "Building React frontend..."
          yarn nx build app --prod
          echo "artifact_path=dist/apps/app" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend build completed"

      - name: Build Backend (Express API)
        id: build_backend
        run: |
          echo "Building Express.js backend..."
          yarn nx build api --prod
          echo "artifact_path=dist/apps/api" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend build completed"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            dist/apps/app/
            dist/apps/api/
          retention-days: 7

  # Testing Phase
  testing:
    name: 'Comprehensive Testing Suite'
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        test-type: [unit, security, performance]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install Dependencies
        run: yarn install --frozen-lockfile

      - name: Unit Tests
        if: matrix.test-type == 'unit'
        run: |
          echo "Running unit tests..."
          yarn nx test api --coverage --watchAll=false
          yarn nx test app --coverage --watchAll=false
          echo "‚úÖ Unit tests completed"

      - name: Security Scans
        if: matrix.test-type == 'security'
        run: |
          echo "Running security scans..."
          # Install and run npm audit
          yarn audit --level moderate || true
          echo "‚úÖ Security scan completed"

      - name: Performance Testing
        if: matrix.test-type == 'performance'
        run: |
          echo "Running performance tests..."
          # Lighthouse CI or performance testing would go here
          echo "‚úÖ Performance testing completed"

  # Database Setup Phase
  database_setup:
    name: 'PostgreSQL Database Setup'
    runs-on: ubuntu-latest
    needs: testing
    outputs:
      db_endpoint: ${{ steps.rds_setup.outputs.endpoint }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup RDS PostgreSQL (Free Tier)
        id: rds_setup
        run: |
          echo "Setting up RDS PostgreSQL instance..."
          
          # Check if RDS instance already exists
          if aws rds describe-db-instances --db-instance-identifier ${{ env.RDS_INSTANCE_ID }} >/dev/null 2>&1; then
            echo "RDS instance already exists"
            ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier ${{ env.RDS_INSTANCE_ID }} --query 'DBInstances[0].Endpoint.Address' --output text)
          else
            echo "Creating new RDS instance..."
            aws rds create-db-instance \
              --db-instance-identifier ${{ env.RDS_INSTANCE_ID }} \
              --db-instance-class db.t2.micro \
              --engine postgres \
              --master-username webappuser \
              --master-user-password ${{ secrets.DB_PASSWORD }} \
              --allocated-storage 20 \
              --publicly-accessible \
              --backup-retention-period 0 \
              --no-multi-az \
              --storage-encrypted false
            
            # Wait for RDS instance to be available
            echo "Waiting for RDS instance to be available..."
            aws rds wait db-instance-available --db-instance-identifier ${{ env.RDS_INSTANCE_ID }}
            
            ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier ${{ env.RDS_INSTANCE_ID }} --query 'DBInstances[0].Endpoint.Address' --output text)
          fi
          
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "‚úÖ Database setup completed"

  # Lambda Deployment Phase
  lambda_deployment:
    name: 'Backend API Deployment (Lambda)'
    runs-on: ubuntu-latest
    needs: [database_setup, build]
    outputs:
      api_url: ${{ steps.lambda_deploy.outputs.function_url }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Prepare Lambda Package
        run: |
          echo "Preparing Lambda deployment package..."
          cd dist/apps/api
          
          # Create lambda handler wrapper
          cat > lambda-handler.js << 'EOF'
          const serverlessExpress = require('aws-serverless-express');
          const app = require('./main.js').app || require('./main.js');
          
          const server = serverlessExpress.createServer(app);
          
          exports.handler = (event, context) => {
            console.log('Lambda handler invoked');
            return serverlessExpress.proxy(server, event, context);
          };
          EOF
          
          # Create package.json for Lambda
          cat > package.json << 'EOF'
          {
            "name": "webapp-demo-api",
            "version": "1.0.0",
            "dependencies": {
              "aws-serverless-express": "^3.4.0",
              "express": "^4.18.1",
              "pg": "^8.7.3",
              "typeorm": "^0.3.7",
              "cors": "^2.8.5"
            }
          }
          EOF
          
          # Install production dependencies
          npm install --production
          
          # Create deployment package
          zip -r ../../../lambda-deployment.zip .
          
          echo "‚úÖ Lambda package prepared"

      - name: Deploy Lambda Function
        id: lambda_deploy
        run: |
          echo "Deploying Lambda function..."
          
          # Check if function exists
          if aws lambda get-function --function-name ${{ env.LAMBDA_FUNCTION_NAME }} >/dev/null 2>&1; then
            echo "Updating existing Lambda function..."
            aws lambda update-function-code \
              --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
              --zip-file fileb://lambda-deployment.zip
          else
            echo "Creating new Lambda function..."
            aws lambda create-function \
              --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
              --runtime nodejs18.x \
              --role arn:aws:iam::073651099697:role/webapp-demo-lambda-role \
              --handler lambda-handler.handler \
              --zip-file fileb://lambda-deployment.zip \
              --timeout 30 \
              --memory-size 512 \
              --environment Variables="{
                DB_HOST=${{ needs.database_setup.outputs.db_endpoint }},
                DB_USER=webappuser,
                DB_PASSWORD=${{ secrets.DB_PASSWORD }},
                DB_NAME=postgres
              }"
          fi
          
          # Create function URL for public access
          if ! aws lambda get-function-url-config --function-name ${{ env.LAMBDA_FUNCTION_NAME }} >/dev/null 2>&1; then
            aws lambda create-function-url-config \
              --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
              --auth-type NONE \
              --cors '{
                "AllowCredentials": false,
                "AllowHeaders": ["*"],
                "AllowMethods": ["*"],
                "AllowOrigins": ["*"],
                "ExposeHeaders": ["*"],
                "MaxAge": 3600
              }'
          fi
          
          FUNCTION_URL=$(aws lambda get-function-url-config --function-name ${{ env.LAMBDA_FUNCTION_NAME }} --query 'FunctionUrl' --output text)
          echo "function_url=$FUNCTION_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Lambda deployment completed"

  # Frontend Deployment Phase
  frontend_deployment:
    name: 'Frontend Deployment (S3)'
    runs-on: ubuntu-latest
    needs: [lambda_deployment, build]
    outputs:
      website_url: ${{ steps.s3_deploy.outputs.website_url }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Update Frontend Configuration
        run: |
          echo "Updating frontend configuration with API endpoint..."
          cd dist/apps/app
          
          # Create config file with API endpoint
          cat > config.js << EOF
          window.API_ENDPOINT = '${{ needs.lambda_deployment.outputs.api_url }}';
          EOF
          
          # Update index.html to include config
          if [ -f index.html ]; then
            sed -i 's/<head>/<head>\n  <script src="config.js"><\/script>/' index.html
          fi
          
          echo "‚úÖ Frontend configuration updated"

      - name: Deploy to S3
        id: s3_deploy
        run: |
          echo "Deploying frontend to S3..."
          
          # Sync files to S3
          aws s3 sync dist/apps/app/ s3://${{ env.S3_BUCKET }}/ --delete
          
          # Set correct content types
          aws s3 cp s3://${{ env.S3_BUCKET }}/ s3://${{ env.S3_BUCKET }}/ \
            --recursive \
            --metadata-directive REPLACE \
            --content-type "text/html" \
            --exclude "*" \
            --include "*.html"
          
          aws s3 cp s3://${{ env.S3_BUCKET }}/ s3://${{ env.S3_BUCKET }}/ \
            --recursive \
            --metadata-directive REPLACE \
            --content-type "application/javascript" \
            --exclude "*" \
            --include "*.js"
          
          aws s3 cp s3://${{ env.S3_BUCKET }}/ s3://${{ env.S3_BUCKET }}/ \
            --recursive \
            --metadata-directive REPLACE \
            --content-type "text/css" \
            --exclude "*" \
            --include "*.css"
          
          WEBSITE_URL="http://${{ env.S3_BUCKET }}.s3-website-${{ env.AWS_REGION }}.amazonaws.com"
          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend deployment completed"

  # Monitoring and Validation Phase
  monitoring_setup:
    name: 'CloudWatch Monitoring Setup'
    runs-on: ubuntu-latest
    needs: [frontend_deployment, lambda_deployment]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup CloudWatch Alarms
        run: |
          echo "Setting up CloudWatch monitoring..."
          
          # Lambda Error Rate Alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "webapp-demo-lambda-errors" \
            --alarm-description "Lambda function error rate alarm" \
            --metric-name Errors \
            --namespace AWS/Lambda \
            --statistic Sum \
            --period 300 \
            --threshold 5 \
            --comparison-operator GreaterThanThreshold \
            --dimensions Name=FunctionName,Value=${{ env.LAMBDA_FUNCTION_NAME }} \
            --evaluation-periods 2 \
            --treat-missing-data notBreaching
          
          # Lambda Duration Alarm
          aws cloudwatch put-metric-alarm \
            --alarm-name "webapp-demo-lambda-duration" \
            --alarm-description "Lambda function duration alarm" \
            --metric-name Duration \
            --namespace AWS/Lambda \
            --statistic Average \
            --period 300 \
            --threshold 25000 \
            --comparison-operator GreaterThanThreshold \
            --dimensions Name=FunctionName,Value=${{ env.LAMBDA_FUNCTION_NAME }} \
            --evaluation-periods 2 \
            --treat-missing-data notBreaching
          
          echo "‚úÖ CloudWatch monitoring setup completed"

  # Deployment Validation
  deployment_validation:
    name: 'Post-Deployment Validation'
    runs-on: ubuntu-latest
    needs: [frontend_deployment, lambda_deployment, monitoring_setup]
    outputs:
      validation_status: ${{ steps.validate.outputs.status }}
      frontend_health: ${{ steps.validate.outputs.frontend_health }}
      backend_health: ${{ steps.validate.outputs.backend_health }}
    steps:
      - name: Validate Frontend Deployment
        id: validate
        run: |
          echo "Validating deployment..."
          
          FRONTEND_URL="${{ needs.frontend_deployment.outputs.website_url }}"
          API_URL="${{ needs.lambda_deployment.outputs.api_url }}"
          
          echo "Testing frontend accessibility..."
          if curl -f -s "$FRONTEND_URL" > /dev/null; then
            echo "frontend_health=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Frontend is accessible"
          else
            echo "frontend_health=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ùå Frontend is not accessible"
          fi
          
          echo "Testing API endpoint..."
          if curl -f -s "$API_URL" > /dev/null; then
            echo "backend_health=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Backend API is accessible"
          else
            echo "backend_health=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ùå Backend API is not accessible"
          fi
          
          echo "status=completed" >> $GITHUB_OUTPUT

  # Cost Analysis and Reporting
  cost_analysis:
    name: 'Cost Analysis & Reporting'
    runs-on: ubuntu-latest
    needs: [deployment_validation]
    if: always()
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Generate Cost Report
        run: |
          echo "Generating cost analysis report..."
          
          cat > cost-report.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>Webapp Demo - Pipeline Cost Analysis</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              .header { background: #f0f0f0; padding: 15px; border-radius: 5px; }
              .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
              .cost-item { display: flex; justify-content: space-between; margin: 10px 0; }
              .free-tier { color: green; font-weight: bold; }
              .warning { color: orange; }
              .error { color: red; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>CI/CD Pipeline Cost Analysis Report</h1>
              <p>Generated: $(date)</p>
              <p>Cost Constraint: Free Tier Only</p>
            </div>
            
            <div class="section">
              <h2>AWS Services Used</h2>
              <div class="cost-item">
                <span>S3 Static Website Hosting</span>
                <span class="free-tier">FREE (within 5GB limit)</span>
              </div>
              <div class="cost-item">
                <span>Lambda Functions</span>
                <span class="free-tier">FREE (within 1M requests/month)</span>
              </div>
              <div class="cost-item">
                <span>RDS PostgreSQL (db.t2.micro)</span>
                <span class="free-tier">FREE (750 hours/month for 12 months)</span>
              </div>
              <div class="cost-item">
                <span>CloudWatch Alarms</span>
                <span class="free-tier">FREE (within 10 alarms limit)</span>
              </div>
              <div class="cost-item">
                <span>CodeBuild</span>
                <span class="free-tier">FREE (100 minutes/month)</span>
              </div>
            </div>
            
            <div class="section">
              <h2>Pipeline Execution Summary</h2>
              <p><strong>Frontend URL:</strong> ${{ needs.frontend_deployment.outputs.website_url }}</p>
              <p><strong>API URL:</strong> ${{ needs.lambda_deployment.outputs.api_url }}</p>
              <p><strong>Frontend Health:</strong> ${{ needs.deployment_validation.outputs.frontend_health }}</p>
              <p><strong>Backend Health:</strong> ${{ needs.deployment_validation.outputs.backend_health }}</p>
            </div>
            
            <div class="section">
              <h2>Free Tier Compliance</h2>
              <p class="free-tier">‚úÖ All services are within AWS Free Tier limits</p>
              <p>This deployment will not incur charges if you stay within free tier quotas.</p>
            </div>
            
            <div class="section">
              <h2>Cleanup Schedule</h2>
              <p>Cleanup setting: ${{ github.event.inputs.cleanup_schedule || 'no-cleanup' }}</p>
              <p>To minimize costs, consider cleanup options if you don't need persistent resources.</p>
            </div>
          </body>
          </html>
          EOF
          
          echo "‚úÖ Cost analysis report generated"

      - name: Upload Cost Report
        uses: actions/upload-artifact@v4
        with:
          name: cost-analysis-report
          path: cost-report.html

  # Resource Cleanup Job (Conditional)
  resource_cleanup:
    name: 'Resource Cleanup'
    runs-on: ubuntu-latest
    needs: [deployment_validation, cost_analysis]
    if: github.event.inputs.cleanup_schedule != 'no-cleanup' && github.event.inputs.cleanup_schedule != ''
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Schedule Cleanup
        run: |
          CLEANUP_TIME="${{ github.event.inputs.cleanup_schedule }}"
          
          case $CLEANUP_TIME in
            "immediately")
              echo "Performing immediate cleanup..."
              # Add cleanup commands here
              ;;
            "15-minutes"|"30-minutes"|"45-minutes"|"60-minutes")
              echo "Cleanup scheduled for: $CLEANUP_TIME"
              # In a real scenario, you'd schedule this via AWS EventBridge or similar
              echo "Note: Automated cleanup scheduling would require additional setup"
              ;;
          esac

  # Final Status Report
  pipeline_status:
    name: 'Pipeline Status Report'
    runs-on: ubuntu-latest
    needs: [deployment_validation, cost_analysis]
    if: always()
    steps:
      - name: Generate Final Report
        run: |
          echo "=== WEBAPP DEMO CI/CD PIPELINE COMPLETED ==="
          echo ""
          echo "üåê Frontend URL: ${{ needs.frontend_deployment.outputs.website_url }}"
          echo "üîó API URL: ${{ needs.lambda_deployment.outputs.api_url }}"
          echo "üìä Frontend Health: ${{ needs.deployment_validation.outputs.frontend_health }}"
          echo "üìä Backend Health: ${{ needs.deployment_validation.outputs.backend_health }}"
          echo "üí∞ Cost Compliance: FREE TIER ONLY"
          echo ""
          echo "üéØ Pipeline executed successfully following the YAML configuration!"
          echo "üìÑ Detailed cost analysis and HTML report available in artifacts."
          echo ""
          if [ "${{ github.event.inputs.cleanup_schedule }}" != "no-cleanup" ]; then
            echo "üßπ Cleanup scheduled: ${{ github.event.inputs.cleanup_schedule }}"
          else
            echo "üßπ No cleanup scheduled - resources will remain active"
          fi